#include "Bisection.h"
#include <iostream>

// Given a function f, and an interval [a, b] (or [b, a]), such that f(a)*f(b) < 0.0, this
// method finds a value c in the interval, such that f(c) = 0.0, approximately,
// by means of the regula falsi method.
//
int Bisection::bisection_method(const double &t_in, const double &t_fin, double epsilon, double &t_c, int (*f)(const double &x, double &y, void *o, void *d), void *object, void *data){
    double a(t_in), b(t_fin);

    double f_a;
    int info_f_a = (*f)(a, f_a, object, data);

    double f_b;
    int info_f_b = (*f)(b, f_b, object, data);

    if (info_f_a == BISECTION_FUNCTION_ERROR || 
        info_f_b == BISECTION_FUNCTION_ERROR) return BISECTION_FUNCTION_ERROR;

    if (f_a*f_b > 0.0) return BISECTION_EQUAL_SIGN;

    double tol = epsilon*(fabs(t_in) + fabs(t_fin));
    int max_count = 50;
    int count = 1;

    double c_old(a);
    t_c = b;

    while (fabs(c_old - t_c) > tol && count <= max_count){
//        std::cout << "c_old = " << c_old << ", c = " << c << ", fabs(c_old - c) = " << fabs(c_old - c) << std::endl;
//        std::cout << "    a = " << a << ",f(a) = " << f_a << ", b = " << b << ", f(b) = " << f_b<< std::endl << std::endl;

        c_old = t_c;

//        double alpha = f_b/(f_b - f_a); 
        double alpha = 0.5;
        t_c = alpha*a + (1.0 - alpha)*b;

        double f_c;
        int info_f_c = (*f)(t_c, f_c, object, data);

        if (info_f_c == BISECTION_FUNCTION_ERROR) return BISECTION_FUNCTION_ERROR;

        if (f_c*f_b >= 0.0){
            b   = t_c;
            f_b = f_c;
        }
        else {
            a   = t_c;
            f_a = f_c;
        }

        count++;
    }

    std::cout << "RF. count = " << count << std::endl;

    if (count > max_count) return BISECTION_CONVERGENCE_ERROR;
    else                   return BISECTION_CONVERGENCE_OK;
}
