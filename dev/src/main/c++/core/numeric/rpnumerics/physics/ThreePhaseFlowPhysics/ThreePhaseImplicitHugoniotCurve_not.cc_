#include "ThreePhaseImplicitHugoniotCurve.h"

ThreePhaseImplicitHugoniotCurve::ThreePhaseImplicitHugoniotCurve(ThreePhaseFlowSubPhysics *s): ImplicitHugoniotCurve(s->flux(), s->accumulation(), s->boundary()), 
                                                                                               subphysics_(s),
                                                                                               permeability_(s->permeability())  {
     method_ = IMPLICIT_HUGONIOT;
     info_ = std::string("ThreePhaseImplicitHugoniotCurve");
}

ThreePhaseImplicitHugoniotCurve::~ThreePhaseImplicitHugoniotCurve(){
}

int ThreePhaseImplicitHugoniotCurve::classic_function_on_square(ImplicitHugoniotCurve *obj, double *foncub, int i, int j){
    return obj->ImplicitHugoniotCurve::function_on_square(foncub, i, j);
}

int ThreePhaseImplicitHugoniotCurve::threephase_function_on_square(ImplicitHugoniotCurve *obj, double *foncub, int i, int j){
    int is_square = obj->gv->cell_type(i, j);

    RealVector state(2); //state(3);
    RealVector f_aux(4);

    for (int l = 0; l < 2; l++) {
        for (int k = 0; k < 2; k++) {
            state(0) = obj->gv->grid(i + l, j + k).component(0);
            state(1) = obj->gv->grid(i + l, j + k).component(1);

            f_aux(l * 2 + k) = (obj->(*implicit_Hugoniot_function))((ThreePhaseImplicitHugoniotCurve*)obj, state);
        }
    }

    foncub[1] = f_aux(0); // Was: foncub[0][1]
    foncub[0] = f_aux(2); // Was: foncub[0][0]
    foncub[3] = f_aux(1); // Was: foncub[0][2]

    // Only useful if the cell is a square.
    //
    if (is_square == CELL_IS_SQUARE) foncub[2] = f_aux(3); // Was: foncub[0][2]

    return 1;
}

int ThreePhaseImplicitHugoniotCurve::function_on_square(double *foncub, int i, int j) {
//    int is_square = gv->cell_type(i, j);

//    RealVector state(2); //state(3);
//    RealVector f_aux(4);

//    for (int l = 0; l < 2; l++) {
//        for (int k = 0; k < 2; k++) {
//            state(0) = gv->grid(i + l, j + k).component(0);
//            state(1) = gv->grid(i + l, j + k).component(1);

//            f_aux(l * 2 + k) = (*implicit_Hugoniot_function)(this, state);
//        }
//    }

//    foncub[1] = f_aux(0); // Was: foncub[0][1]
//    foncub[0] = f_aux(2); // Was: foncub[0][0]
//    foncub[3] = f_aux(1); // Was: foncub[0][2]

//    // Only useful if the cell is a square.
//    //
//    if (is_square == CELL_IS_SQUARE) foncub[2] = f_aux(3); // Was: foncub[0][2]

//    return 1;

    
    return (*function_on_square_to_be_used)(this, foncub, i, j);
}

double ThreePhaseImplicitHugoniotCurve::gas_vertex_function(ThreePhaseImplicitHugoniotCurve *obj, const RealVector &state){
    RealVector redperm(3);
    obj->permeability_->reduced_permeability(state, redperm);

    JetMatrix water(2);
    obj->permeability_->PermeabilityWater_jet(state, 0, water);
    double lambda_w = water.get(0)/obj->muw; // kw/muw

    JetMatrix oil(2);
    obj->permeability_->PermeabilityOil_jet(state, 0, oil);
    double lambda_o = oil.get(0)/obj->muo; // ko/muo

    JetMatrix gas(2);
    obj->permeability_->PermeabilityGas_jet(state, 0, gas);
    double lambda_g = gas.get(0)/obj->mug; // kg/mug

    double oil_factor   = (redperm(1)/obj->muo)*(obj->vel + lambda_g*obj->rho_o_g + lambda_w*obj->rho_o_w);
    double water_factor = (redperm(0)/obj->muw)*(obj->vel + lambda_g*obj->rho_w_g + lambda_o*obj->rho_w_o);

    return oil_factor - water_factor;
}

double ThreePhaseImplicitHugoniotCurve::water_vertex_function(ThreePhaseImplicitHugoniotCurve *obj, const RealVector &state){
    RealVector redperm(3);
    obj->permeability_->reduced_permeability(state, redperm);

    JetMatrix water(2);
    obj->permeability_->PermeabilityWater_jet(state, 0, water);
    double lambda_w = water.get(0)/obj->muw; // kw/muw

    JetMatrix oil(2);
    obj->permeability_->PermeabilityOil_jet(state, 0, oil);
    double lambda_o = oil.get(0)/obj->muo; // ko/muo

    JetMatrix gas(2);
    obj->permeability_->PermeabilityGas_jet(state, 0, gas);
    double lambda_g = gas.get(0)/obj->mug; // kg/mug

    double oil_factor   = (redperm(1)/obj->muo)*(obj->vel + lambda_g*obj->rho_o_g + lambda_w*obj->rho_o_w);
    double gas_factor   = (redperm(2)/obj->mug)*(obj->vel + lambda_w*obj->rho_g_w + lambda_o*obj->rho_g_o);

    return oil_factor - gas_factor;
}

double ThreePhaseImplicitHugoniotCurve::oil_vertex_function(ThreePhaseImplicitHugoniotCurve *obj, const RealVector &state){
    RealVector redperm(3);
    obj->permeability_->reduced_permeability(state, redperm);

    JetMatrix water(2);
    obj->permeability_->PermeabilityWater_jet(state, 0, water);
    double lambda_w = water.get(0)/obj->muw; // kw/muw

    JetMatrix oil(2);
    obj->permeability_->PermeabilityOil_jet(state, 0, oil);
    double lambda_o = oil.get(0)/obj->muo; // ko/muo

    JetMatrix gas(2);
    obj->permeability_->PermeabilityGas_jet(state, 0, gas);
    double lambda_g = gas.get(0)/obj->mug; // kg/mug

    double water_factor = (redperm(0)/obj->muw)*(obj->vel + lambda_g*obj->rho_w_g + lambda_o*obj->rho_w_o);
    double gas_factor   = (redperm(2)/obj->mug)*(obj->vel + lambda_w*obj->rho_g_w + lambda_o*obj->rho_g_o);

    return water_factor - gas_factor;
}

double ThreePhaseImplicitHugoniotCurve::water_gas_side_function(ThreePhaseImplicitHugoniotCurve *obj, const RealVector &state){
    double sw = state(0);
    double sw_ref = obj->reference_point.point(0);

    RealVector redperm(3);
    obj->permeability_->reduced_permeability(state, redperm);

    JetMatrix water(2);
    obj->permeability_->PermeabilityWater_jet(state, 0, water);
    double lambda_w = water.get(0)/obj->muw; // kw/muw

    JetMatrix oil(2);
    obj->permeability_->PermeabilityOil_jet(state, 0, oil);
    double lambda_o = oil.get(0)/obj->muo; // ko/muo

    JetMatrix gas(2);
    obj->permeability_->PermeabilityGas_jet(state, 0, gas);
    double lambda_g = gas.get(0)/obj->mug; // kg/mug

    double lambda = lambda_w + lambda_o + lambda_g;

    double term1   = (redperm(1)/(obj->muo*lambda))*(obj->vel + lambda_g*obj->rho_o_g + lambda_w*obj->rho_o_w)*(sw_ref - sw);

    double term2   = (obj->lambda_w_ref/(obj->lambda_w_ref + obj->lambda_g_ref))*(obj->vel + obj->lambda_g_ref*obj->rho_w_g);

    double term3 = (lambda_w/lambda)*(obj->vel + lambda_g*obj->rho_w_g + lambda_o*obj->rho_w_o);

    return term1 - term2 + term3;
}

double ThreePhaseImplicitHugoniotCurve::water_oil_side_function(ThreePhaseImplicitHugoniotCurve *obj, const RealVector &state){
    double sw = state(0);
    double sw_ref = obj->reference_point.point(0);

    RealVector redperm(3);
    obj->permeability_->reduced_permeability(state, redperm);

    JetMatrix water(2);
    obj->permeability_->PermeabilityWater_jet(state, 0, water);
    double lambda_w = water.get(0)/obj->muw; // kw/muw

    JetMatrix oil(2);
    obj->permeability_->PermeabilityOil_jet(state, 0, oil);
    double lambda_o = oil.get(0)/obj->muo; // ko/muo

    JetMatrix gas(2);
    obj->permeability_->PermeabilityGas_jet(state, 0, gas);
    double lambda_g = gas.get(0)/obj->mug; // kg/mug

    double lambda = lambda_w + lambda_o + lambda_g;

    double term1   = (redperm(2)/(obj->mug*lambda))*(obj->vel + lambda_w*obj->rho_g_w + lambda_o*obj->rho_g_o)*(sw_ref - sw);

    double term2 = (obj->lambda_w_ref/(obj->lambda_w_ref + obj->lambda_o_ref))*(obj->vel + obj->lambda_o_ref*obj->rho_w_o);

    double term3   = (lambda_w/lambda)*(obj->vel + lambda_g*obj->rho_w_g + lambda_o*obj->rho_w_o);

    return term1 - term2 + term3;
}

double ThreePhaseImplicitHugoniotCurve::oil_gas_side_function(ThreePhaseImplicitHugoniotCurve *obj, const RealVector &state){
    double so = state(1);
    double so_ref = obj->reference_point.point(1);

    RealVector redperm(3);
    obj->permeability_->reduced_permeability(state, redperm);

    JetMatrix water(2);
    obj->permeability_->PermeabilityWater_jet(state, 0, water);
    double lambda_w = water.get(0)/obj->muw; // kw/muw

    JetMatrix oil(2);
    obj->permeability_->PermeabilityOil_jet(state, 0, oil);
    double lambda_o = oil.get(0)/obj->muo; // ko/muo

    JetMatrix gas(2);
    obj->permeability_->PermeabilityGas_jet(state, 0, gas);
    double lambda_g = gas.get(0)/obj->mug; // kg/mug

    double lambda = lambda_w + lambda_o + lambda_g;

    double term1 = (redperm(0)/(obj->muw*lambda))*(obj->vel + lambda_g*obj->rho_w_g + lambda_o*obj->rho_w_o)*(so_ref - so);

    double term2 = (obj->lambda_o_ref/(obj->lambda_o_ref + obj->lambda_g_ref))*(obj->vel + obj->lambda_g_ref*obj->rho_o_g);

    double term3 = (lambda_o/lambda)*(obj->vel + lambda_g*obj->rho_o_g + lambda_w*obj->rho_o_w);

    return term1 - term2 + term3;
}

void ThreePhaseImplicitHugoniotCurve::curve(const ReferencePoint &ref, int type, std::vector<Curve> &c){
    if (subphysics_ != 0) gv = subphysics_->gridvalues();

    if (type == THREEPHASEIMPLICITHUGONIOTCURVE_G_VERTEX){
        implicit_Hugoniot_function = &gas_vertex_function;

        function_on_square_to_be_used = &threephase_function_on_square;

        // No projection is necessary.
        reference_point.point = subphysics_->G();
    }
    else if (type == THREEPHASEIMPLICITHUGONIOTCURVE_W_VERTEX){
        implicit_Hugoniot_function = &water_vertex_function;

        function_on_square_to_be_used = &threephase_function_on_square;

        // No projection is necessary.
        reference_point.point = subphysics_->W();
    }
    else if (type == THREEPHASEIMPLICITHUGONIOTCURVE_O_VERTEX){
        implicit_Hugoniot_function = &oil_vertex_function;

        function_on_square_to_be_used = &threephase_function_on_square;

        // No projection is necessary.
        reference_point.point = subphysics_->O();
    }
    else if (type == THREEPHASEIMPLICITHUGONIOTCURVE_GW_SIDE) {
        implicit_Hugoniot_function = &water_gas_side_function;

        function_on_square_to_be_used = &threephase_function_on_square;

        RealVector projected_point = project_point_onto_line_2D(ref.point, subphysics_->G(), subphysics_->W());
        reference_point = ReferencePoint(projected_point, subphysics_->flux(), subphysics_->accumulation(), 0);
    }
    else if (type == THREEPHASEIMPLICITHUGONIOTCURVE_WO_SIDE) {
        implicit_Hugoniot_function = &water_oil_side_function;

        function_on_square_to_be_used = &threephase_function_on_square;

        RealVector projected_point = project_point_onto_line_2D(ref.point, subphysics_->W(), subphysics_->O());
        reference_point = ReferencePoint(projected_point, subphysics_->flux(), subphysics_->accumulation(), 0);
    }
    else if (type == THREEPHASEIMPLICITHUGONIOTCURVE_GO_SIDE) {
        implicit_Hugoniot_function = &oil_gas_side_function;

        function_on_square_to_be_used = &threephase_function_on_square;

        RealVector projected_point = project_point_onto_line_2D(ref.point, subphysics_->G(), subphysics_->O());
        reference_point = ReferencePoint(projected_point, subphysics_->flux(), subphysics_->accumulation(), 0);
    }
    else {
        // Generic.
        //
        reference_point = ref;

        function_on_square_to_be_used = &classic_function_on_square;

        // Invoke the base's class' method.
        //
        ImplicitHugoniotCurve::curve(ref, IMPLICITHUGONIOTCURVE_GENERIC_POINT, c);

        return;
    }

    vel = subphysics_->vel()->value();
    muw = subphysics_->muw()->value();
    muo = subphysics_->muo()->value();
    mug = subphysics_->mug()->value();
    grw = subphysics_->grw()->value();
    gro = subphysics_->gro()->value();
    grg = subphysics_->grg()->value();

    rho_w_o = grw - gro; // rho12
    rho_o_w = -rho_w_o;  // rho21

    rho_w_g = grw - grg; // rho13
    rho_g_w = -rho_w_g;  // rho31

    rho_o_g = gro - grg; // rho23
    rho_g_o = -rho_o_g;  // rho32

    JetMatrix water(2);
    permeability_->PermeabilityWater_jet(reference_point.point, 0, water);
    lambda_w_ref = water.get(0)/muw; // kw/muw

    JetMatrix oil(2);
    permeability_->PermeabilityOil_jet(reference_point.point, 0, oil);
    lambda_o_ref = oil.get(0)/muo; // ko/muo

    JetMatrix gas(2);
    permeability_->PermeabilityGas_jet(reference_point.point, 0, gas);
    lambda_g_ref = gas.get(0)/mug; // kg/mug

    std::vector<RealVector> hugoniot_curve;
    std::vector< std::deque <RealVector> > curves;
    std::vector <bool> is_circular;

    int method = SEGMENTATION_METHOD;
    int info = ContourMethod::contour2d(this, hugoniot_curve, curves, is_circular, method);

    for (int i = 0; i < hugoniot_curve.size()/2; i++){
        Curve temp;
        temp.curve.push_back(hugoniot_curve[2*i]);
        temp.curve.push_back(hugoniot_curve[2*i + 1]);

        c.push_back(temp);
    }

    return;
}

