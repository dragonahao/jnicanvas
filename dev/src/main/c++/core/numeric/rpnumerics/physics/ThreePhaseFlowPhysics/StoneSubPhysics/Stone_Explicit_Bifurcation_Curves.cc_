#include "Stone_Explicit_Bifurcation_Curves.h"

Stone_Explicit_Bifurcation_Curves::Stone_Explicit_Bifurcation_Curves(StoneFluxFunction *ff){
    f = ff;
}

Stone_Explicit_Bifurcation_Curves::~Stone_Explicit_Bifurcation_Curves(){
}

void Stone_Explicit_Bifurcation_Curves::line(const RealVector &p, const RealVector &q, int nos, std::vector<RealVector> &v){
    v.clear();

    RealVector delta = (q - p)/((double)nos);

    // Add first point (p).
    //
    v.push_back(p);

    // Not starting a 0!!!
    //
    for (int i = 1; i <= nos; i++){
        RealVector temp = p + delta*((double)i);

        // Add two copies of the new point...
        //
        v.push_back(temp);
        v.push_back(temp);
    }

    // ...and remove the second copy of the last point.
    //
    v.pop_back();

    return;
}

void Stone_Explicit_Bifurcation_Curves::expl_sec_bif_crv(int side_opposite_vertex, int nos, 
                                                         std::vector<RealVector> &vertex_to_umbilic, 
                                                         std::vector<RealVector> &umbilic_to_side){
    vertex_to_umbilic.clear();
    umbilic_to_side.clear();

    RealVector permeability_params = f->perm().params().params();

    double expw = permeability_params(0);
    double expg = permeability_params(1);
    double expo = permeability_params(2);

    double expow = permeability_params(3);
    double expog = permeability_params(4);

    double cnw = permeability_params(5);
    double cng = permeability_params(6);
    double cno = permeability_params(7);

    double lw = permeability_params(8);
    double lg = permeability_params(9);

    double low = permeability_params(10);
    double log = permeability_params(11);

    double epsl = permeability_params(12);

    // Only compute the curves in this case.
    //
    if (expw  == 2.0 && expg  == 2.0 && expo == 2.0 &&
        expow == 2.0 && expog == 2.0 &&
        cnw   == 0.0 && cng   == 0.0 && cno == 0.0 &&
        low   == 0.0 && log   == 0.0 &&
        epsl  == 0.0 ){

        // muw, muo, mug
        RealVector flux_params = f->fluxParams().params();

        double muw = flux_params(3);
        double mug = flux_params(4);
        double muo = flux_params(5);

        double sum_mu = muw + muo + mug;

        // Umbilic point.
        //
        RealVector umbp(2);
        umbp(0) = muw/sum_mu;
        umbp(1) = muo/sum_mu;

        // Just in case...
        //
        nos = std::max(2, nos);

        // Endpoints
        RealVector vertex(2), point_on_side(2);

        if (side_opposite_vertex == THREE_PHASE_BOUNDARY_SW_ZERO){
            // From the vertex to the umbilic
            vertex(0) = 1.0;
            vertex(1) = 0.0;

            // From the umbilic to the side.
            //
            point_on_side(0) = 0.0;
            point_on_side(1) = muo/(mug + muo); // Equation of line from            sg/mug = so/muo
                                                //                       (1 - sw - so)/mug = so/muo, or, (1 - sw - so)*muo - so*mug = 0.
        }
        else if (side_opposite_vertex == THREE_PHASE_BOUNDARY_SO_ZERO){
            // From the vertex to the umbilic
            vertex(0) = 0.0;
            vertex(1) = 1.0;

            // From the umbilic to the side.
            //
            point_on_side(0) = muw/(muw + mug); // Equation of line from            sw/muw = sg/mug,
                                                //                                  sw/muw = (1 - sw - so)/mug, or, sw*mug - (1 - sw - so)*muw = 0.
            point_on_side(1) = 0.0;
        }
        else {
            // From the vertex to the umbilic
            vertex(0) = 0.0;
            vertex(1) = 0.0;

            // From the umbilic to the side.
            //
            point_on_side(0) = muw/(muw + muo); // Equation of line from            sw/muw = so/muo, or, sw*muo - so*muw = 0.
            point_on_side(1) = muo/(muw + muo);
        }

        line(vertex, umbp, nos, vertex_to_umbilic);
        line(umbp, point_on_side, nos, umbilic_to_side);
    }

    return;
}

RealVector Stone_Explicit_Bifurcation_Curves::equations(const RealVector &point){
    // muw, muo, mug
    RealVector flux_params = f->fluxParams().params();

    double muw = flux_params(3);
    double mug = flux_params(4);
    double muo = flux_params(5);

    double sw = point(0);
    double so = point(1);

    RealVector eq(3);

    eq(0) = -((1.0 - sw - so)*muo - so*mug);
    eq(1) = sw*mug - (1.0 - sw - so)*muw;
    eq(2) = -(sw*muo - so*muw);

    return eq;
}

int Stone_Explicit_Bifurcation_Curves::region(const RealVector &equations){
    double eq_SW = equations(0);
    double eq_SO = equations(1);
    double eq_SG = equations(2);

    if      (eq_SW < 0.0 && eq_SO < 0.0 && eq_SG < 0.0) return REGION_WM_OM_GM;
    else if (eq_SW < 0.0 && eq_SO > 0.0 && eq_SG < 0.0) return REGION_WM_OP_GM;
    else if (eq_SW > 0.0 && eq_SO > 0.0 && eq_SG < 0.0) return REGION_WP_OP_GM;
    else if (eq_SW > 0.0 && eq_SO > 0.0 && eq_SG > 0.0) return REGION_WP_OP_GP;
    else if (eq_SW > 0.0 && eq_SO < 0.0 && eq_SG > 0.0) return REGION_WP_OM_GP;
    else if (eq_SW < 0.0 && eq_SO < 0.0 && eq_SG > 0.0) return REGION_WM_OM_GP;
}

int Stone_Explicit_Bifurcation_Curves::cross_sec_bif(const RealVector &previous_point, const RealVector &point, RealVector &crossing_point, int &region){
    // muw, muo, mug
    RealVector flux_params = f->fluxParams().params();

    double muw = flux_params(3);
    double mug = flux_params(4);
    double muo = flux_params(5);

    double sw_prev = previous_point(0);
    double so_prev = previous_point(1);

    double sw      = point(0);
    double so      = point(1);

    double eq_SW = (1.0 - sw - so)*muo - so*mug;
    double eq_SO = sw*mug - (1.0 - sw - so)*muw;
    double eq_SG = sw*muo - so*muw;

    eq_SW = -eq_SW;
//    eq_SO = -eq_SO;
    eq_SG = -eq_SG;

    if      (eq_SW < 0.0 && eq_SO < 0.0 && eq_SG < 0.0) region = REGION_WM_OM_GM;
    else if (eq_SW < 0.0 && eq_SO > 0.0 && eq_SG < 0.0) region = REGION_WM_OP_GM;
    else if (eq_SW > 0.0 && eq_SO > 0.0 && eq_SG < 0.0) region = REGION_WP_OP_GM;
    else if (eq_SW > 0.0 && eq_SO > 0.0 && eq_SG > 0.0) region = REGION_WP_OP_GP;
    else if (eq_SW > 0.0 && eq_SO < 0.0 && eq_SG > 0.0) region = REGION_WP_OM_GP;
    else if (eq_SW < 0.0 && eq_SO < 0.0 && eq_SG > 0.0) region = REGION_WM_OM_GP;
    
    return 1;
}

