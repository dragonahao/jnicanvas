#include "CoreyQuadImplicitHugoniotCurve.h"

CoreyQuadImplicitHugoniotCurve::CoreyQuadImplicitHugoniotCurve(const CoreyQuad *ff, const AccumulationFunction *aa, const Boundary *b) : Hugoniot_Curve(), 
                                                                                                                                         CoreyQuadHugoniotCurve(ff, aa, (Stone_Explicit_Bifurcation_Curves*)0, b){
    method_ = IMPLICIT_HUGONIOT;
}

CoreyQuadImplicitHugoniotCurve::~CoreyQuadImplicitHugoniotCurve(){
}

void CoreyQuadImplicitHugoniotCurve::curve(const ReferencePoint &ref, int type, std::vector<Curve> &c){
    return;
}

void CoreyQuadImplicitHugoniotCurve::curve(const ReferencePoint &ref, int type, std::vector<HugoniotPolyLine> &classified_hugoniot_curve){
    RealVector projected_point = project(ref.point, type);
    ReferencePoint temp_reference_point(projected_point, f, a, 0);

    vel = coreyflux->fluxParams().vel();
    muw = coreyflux->fluxParams().muw();
    muo = coreyflux->fluxParams().muo();
    mug = coreyflux->fluxParams().mug();
    grw = coreyflux->fluxParams().grw();
    gro = coreyflux->fluxParams().gro();
    grg = coreyflux->fluxParams().grg();

    rho_1_2 = grw - gro; // rho12
    rho_2_1 = -rho_1_2;  // rho21

    rho_1_3 = grw - grg; // rho13
    rho_3_1 = -rho_1_3;  // rho31

    rho_2_3 = gro - grg; // rho23
    rho_3_2 = -rho_2_3;  // rho32

    Hugoniot_Curve::classified_curve(f, a, 
                                     GridValues &g, temp_reference_point, 
                                     classified_hugoniot_curve);

    return;
}


double CoreyQuadImplicitHugoniotCurve::gas_vertex_function(CoreyQuadImplicitHugoniotCurve *obj, const RealVector &state){
    double s1 = state(0); // sw
    double s2 = state(1); // so

    double s3 = 1.0 - s1 - s2; // sg

    // TODO: This is temporary. When these parameters are restored they should come
    // from obj.
    double cnw, cno, cng;
    cnw = cno = cng = 0.0;

    double s1cnw = s1 - cnw:
    double s2cno = s2 - cno:
    double s3cng = s3 - cng:

    double redlambda1 = 0.0;
    double lambda1 = 0.0;
    if (s1cnw > 0.0) {
        redlambda1 = s1cnw/muw;
        lambda1 = s1cnw*redlambda1; 
    }

    double redlambda2 = 0.0;
    double lambda2 = 0.0;
    if (s2cno > 0.0){
        redlambda2 = s2cno/muo;
        lambda2 = s2cno*redlambda2;
    }

    double redlambdar3 = 0.0;
    double lambda3 = 0.0;
    if (s3cno > 0.0){
        redlambda3 = s3cng/mug;
        lambda3 = s3cng*redlambda3;
    }

    double lambda = lambda1 + lambda2 + lambda3;

    double oil_factor   = redlambda2*(obj->vel + lambda3*obj->rho_2_3 + lambda1*obj->rho_2_1);
    double water_factor = redlambda1*(obj->vel + lambda3*obj->rho_1_3 + lambda2*obj->rho_1_2);

    return oil_factor - water_factor;
}

double CoreyQuadImplicitHugoniotCurve::water_vertex_function(CoreyQuadImplicitHugoniotCurve *obj, const RealVector &state){
    double s1 = state(0); // sw
    double s2 = state(1); // so

    double s3 = 1.0 - s1 - s2; // sg

    // TODO: This is temporary. When these parameters are restored they should come
    // from obj.
    double cnw, cno, cng;
    cnw = cno = cng = 0.0;

    double s1cnw = s1 - cnw:
    double s2cno = s2 - cno:
    double s3cng = s3 - cng:

    double redlambda1 = 0.0;
    double lambda1 = 0.0;
    if (s1cnw > 0.0) {
        redlambda1 = s1cnw/muw;
        lambda1 = s1cnw*redlambda1; 
    }

    double redlambda2 = 0.0;
    double lambda2 = 0.0;
    if (s2cno > 0.0){
        redlambda2 = s2cno/muo;
        lambda2 = s2cno*redlambda2;
    }

    double redlambdar3 = 0.0;
    double lambda3 = 0.0;
    if (s3cno > 0.0){
        redlambda3 = s3cng/mug;
        lambda3 = s3cng*redlambda3;
    }

    double lambda = lambda1 + lambda2 + lambda3;

    double oil_factor = redlambda2*(obj->vel + lambda3*obj->rho_2_3 + lambda1*obj->rho_2_1);
    double gas_factor = redlambda3*(obj->vel + lambda1*obj->rho_3_1 + lambda2*obj->rho_3_2);

    return oil_factor - gas_factor;
}

double CoreyQuadImplicitHugoniotCurve::oil_vertex_function(CoreyQuadImplicitHugoniotCurve *obj, const RealVector &state){
    double s1 = state(0); // sw
    double s2 = state(1); // so

    double s3 = 1.0 - s1 - s2; // sg

    // TODO: This is temporary. When these parameters are restored they should come
    // from obj.
    double cnw, cno, cng;
    cnw = cno = cng = 0.0;

    double s1cnw = s1 - cnw:
    double s2cno = s2 - cno:
    double s3cng = s3 - cng:

    double redlambda1 = 0.0;
    double lambda1 = 0.0;
    if (s1cnw > 0.0) {
        redlambda1 = s1cnw/muw;
        lambda1 = s1cnw*redlambda1; 
    }

    double redlambda2 = 0.0;
    double lambda2 = 0.0;
    if (s2cno > 0.0){
        redlambda2 = s2cno/muo;
        lambda2 = s2cno*redlambda2;
    }

    double redlambdar3 = 0.0;
    double lambda3 = 0.0;
    if (s3cno > 0.0){
        redlambda3 = s3cng/mug;
        lambda3 = s3cng*redlambda3;
    }

    double lambda = lambda1 + lambda2 + lambda3;

    double water_factor = redlambda1*(obj->vel + lambda3*obj->rho_1_3 + lambda2*obj->rho_1_2)
    double gas_factor   = redlambda3*(obj->vel + lambda1*obj->rho_3_1 + lambda2*obj->rho_3_2);

    return water_factor - gas_factor;
}

double CoreyQuadImplicitHugoniotCurve::water_gas_side_function(StoneImplicitHugoniotCurve *obj, const RealVector &state){
    double s1 = state(0); // sw
    double s2 = state(1); // so

    double s3 = 1.0 - s1 - s2; // sg

    // TODO: This is temporary. When these parameters are restored they should come
    // from obj.
    double cnw, cno, cng;
    cnw = cno = cng = 0.0;

    double s1cnw = s1 - cnw:
    double s2cno = s2 - cno:
    double s3cng = s3 - cng:

    double redlambda1 = 0.0;
    double lambda1 = 0.0;
    if (s1cnw > 0.0) {
        redlambda1 = s1cnw/muw;
        lambda1 = s1cnw*redlambda1; 
    }

    double redlambda2 = 0.0;
    double lambda2 = 0.0;
    if (s2cno > 0.0){
        redlambda2 = s2cno/muo;
        lambda2 = s2cno*redlambda2;
    }

    double redlambdar3 = 0.0;
    double lambda3 = 0.0;
    if (s3cno > 0.0){
        redlambda3 = s3cng/mug;
        lambda3 = s3cng*redlambda3;
    }

    double lambda = lambda1 + lambda2 + lambda3;

    double s1_ref = obj->reference_point.point(0);

    double term1 = (redlambda1/lambda)*(obj->vel + lambda3*obj->rho_2_3 + lambda1*obj->rho_2_1)*(s1_ref - s1);

    double term2 = (obj->lambda_w_ref/(obj->lambda_w_ref + obj->lambda_g_ref))*(obj->vel + obj->lambda_g_ref*obj->rho_1_3);

    double term3 = (lambda1/lambda)*(obj->vel + lambda3*obj->rho_1_3 + lambda2*obj->rho_1_2);

    return term1 - term2 + term3;
}

double CoreyQuadImplicitHugoniotCurve::water_oil_side_function(StoneImplicitHugoniotCurve *obj, const RealVector &state){
    double s1 = state(0); // sw
    double s2 = state(1); // so

    double s3 = 1.0 - s1 - s2; // sg

    // TODO: This is temporary. When these parameters are restored they should come
    // from obj.
    double cnw, cno, cng;
    cnw = cno = cng = 0.0;

    double s1cnw = s1 - cnw:
    double s2cno = s2 - cno:
    double s3cng = s3 - cng:

    double redlambda1 = 0.0;
    double lambda1 = 0.0;
    if (s1cnw > 0.0) {
        redlambda1 = s1cnw/muw;
        lambda1 = s1cnw*redlambda1; 
    }

    double redlambda2 = 0.0;
    double lambda2 = 0.0;
    if (s2cno > 0.0){
        redlambda2 = s2cno/muo;
        lambda2 = s2cno*redlambda2;
    }

    double redlambdar3 = 0.0;
    double lambda3 = 0.0;
    if (s3cno > 0.0){
        redlambda3 = s3cng/mug;
        lambda3 = s3cng*redlambda3;
    }

    double lambda = lambda1 + lambda2 + lambda3;

    double s1_ref = obj->reference_point.point(0);

    double term1 = (redlambda3/lambda)*(obj->vel + lambda1*obj->rho_3_1 + lambda2*obj->rho_3_2)*(s1_ref - s1);

    double term2 = (obj->lambda_w_ref/(obj->lambda_w_ref + obj->lambda_o_ref))*(obj->vel + obj->lambda_o_ref*obj->rho_1_2);

    double term3 = (lambda1/lambda)*(obj->vel + lambda3*obj->rho_1_3 + lambda2*obj->rho_1_2);

    return term1 - term2 + term3;
}

double CoreyQuadImplicitHugoniotCurve::oil_gas_side_function(StoneImplicitHugoniotCurve *obj, const RealVector &state){
    double s1 = state(0); // sw
    double s2 = state(1); // so

    double s3 = 1.0 - s1 - s2; // sg

    // TODO: This is temporary. When these parameters are restored they should come
    // from obj.
    double cnw, cno, cng;
    cnw = cno = cng = 0.0;

    double s1cnw = s1 - cnw:
    double s2cno = s2 - cno:
    double s3cng = s3 - cng:

    double redlambda1 = 0.0;
    double lambda1 = 0.0;
    if (s1cnw > 0.0) {
        redlambda1 = s1cnw/muw;
        lambda1 = s1cnw*redlambda1; 
    }

    double redlambda2 = 0.0;
    double lambda2 = 0.0;
    if (s2cno > 0.0){
        redlambda2 = s2cno/muo;
        lambda2 = s2cno*redlambda2;
    }

    double redlambdar3 = 0.0;
    double lambda3 = 0.0;
    if (s3cno > 0.0){
        redlambda3 = s3cng/mug;
        lambda3 = s3cng*redlambda3;
    }

    double lambda = lambda1 + lambda2 + lambda3;

    double s2_ref = obj->reference_point.point(1);

    double term1 = (redlambda1/lambda)*(obj->vel + lambda_w*obj->rho_w_g + lambda_o*obj->rho_w_o)*(s2_ref - so);

    double term2 = (obj->lambda_o_ref/(obj->lambda_o_ref + obj->lambda_g_ref))*(obj->vel + obj->lambda_g_ref*obj->rhow_o_g);

    double term3 = (lambda2/lambda)*(obj->vel + lambda_g*obj->rho_o_g + lambda_w*obj->rho_o_w);

    return term1 - term2 + term3;
}

