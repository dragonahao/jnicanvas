#include "Eigeproblem.h"

// To fill an array of eigen structs. It is assumed that the matrix containing the
// eigenvectors returned by Lapack was tranposed before being fed to
// this function.
//

// vl, vr were filled by LAPACK. Therefore, they are transposed.

void Eigen::fill_eigen(int n, struct eigenpair e[], double rp[], double ip[], const DoubleMatrix &vl, const DoubleMatrix &double &vr){
    int i, j;
    


    for (int i = 0; i < n; i++){
        if (std::abs(ip(i)) < Eigenproblem::epsilon){ // Eigenvalue is real 
            e[i].r = rp(i);
            e[i].i = 0.0;
            for (j = 0; j < n; j++){
                e[i].vlr(j) = vl(j, i);
                e[i].vli(j) = 0.0;
                e[i].vrr(j) = vr(j, i);
                e[i].vri(j) = 0.0;
            }

            e[i].is_real = true;
        }    
        else{                   // Eigenvalue is complex
            if (ip(i) > 0){     // Make sure the eigenvalue's imaginary part is positive.
                                // In this case the i-th column of v contains the real part
                                // of the eigenvector and the (i + 1)-th column contains the
                                // imaginary part of the eigenvector. 
                               
                // If the eigenvalues are complex they are returned by Lapack in conjugated pairs,
                // the first of the pair having positive imaginary part
                e[i].r     = rp(i);
                e[i + 1].r = rp(i);

                e[i].i     =  ip(i);
                e[i + 1].i = -ip(i);

                for (j = 0; j < n; j++){
                    e[i].vlr(j) = vl(j, i);
                    e[i].vli(j) = vl(j, i + 1);
                    
                    e[i + 1].vlr(j) =  vl(j, i);
                    e[i + 1].vli(j) = -vl(j, i + 1);
                    
                    e[i].vrr(j) = vr(j, i);
                    e[i].vri(j) = vr(j, i + 1);
                    
                    e[i + 1].vrr(j) =  vr(j, i);
                    e[i + 1].vri(j) = -vr(j, i + 1);                    
                }
                // End of [4]
                

                e[i].is_real = false;
                e[i + 1].is_real = false;                
                i++;
            }
            else{              // This should never happen, but just in case...
                printf("Problem in fill_eigen! i = %d\n", i);
            }
        }
    }    
    return;
}

void Eigenproblem::eigenproblem(const DoubleMatrix &A, std::vector<Eigenpair> &e){
    int n = A.rows();
    int lda = n, lwork = 5*n, ldvr = n, ldvl = n;

/*    double vr[n][n], vl[n][n];*/
    DoubleMatrix vr(n, n), vl(n, n);

/*    double work[5*n], wi[n], wr[n];*/
    RealVector work(5*n), wi(n), wr(n);

    DoubleMatrix B = transpose(A);

    int info;
    dgeev_("V", "V", &n, B.data(), &lda, wr.components(), wi.components(), 
           vl.data(), &ldvl, vr.data(), &ldvr, work.components(), &lwork, 
           &info);

    // Process the results

    if (info != 0) return EIGENPROBLEM_ERROR;
    else {
        vl = transpose(vl); // ...or else...
        vr = transpose(vr); // ...or else...

        eigenpair e[n];
        for (int i = 0; i < n; i++){
            e[i].vlr.resize(n);
            e[i].vli.resize(n);
            e[i].vrr.resize(n);
            e[i].vri.resize(n);
        }

        fill_eigen(n, e, &wr[0], &wi[0], &vl[0][0], &vr[0][0]);
        sort_eigen(n, e);

        ve.clear();
        ve.resize(n);
        for (int i = 0; i < n; i++) ve[i] = e[i];
        return 0;// SUCCESSFUL_PROCEDURE;

    }

    return EIGENPROBLEM_OK;
}

